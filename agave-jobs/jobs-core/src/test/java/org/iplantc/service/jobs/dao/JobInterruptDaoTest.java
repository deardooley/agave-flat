package org.iplantc.service.jobs.dao;

import java.util.Date;
import java.util.HashMap;
import java.util.List;

import org.iplantc.service.common.persistence.TenancyHelper;
import org.iplantc.service.jobs.exceptions.JobException;
import org.iplantc.service.jobs.model.JobInterrupt;
import org.iplantc.service.jobs.model.enumerations.JobInterruptType;
import org.testng.Assert;
import org.testng.annotations.AfterSuite;
import org.testng.annotations.BeforeSuite;
import org.testng.annotations.Test;

/** Tests in this class run when jobs subsystem is NOT RUNNING and the
 * job_interrupts table is empty.  These tests access the database directly 
 * through a DAO and will conflict with concurrently running application code.
 * 
 * @author rcardone
 */
public class JobInterruptDaoTest 
{
    /* ********************************************************************** */
    /*                                Constants                               */
    /* ********************************************************************** */
    // Total number of interrupts generated by test.
    private final static int NUM_INTERRUPTS = 9;
    
    // Number of interrupts assigned to each job. To get an even distribution
    // of interrupts per job, have this number divide the number of interrupts.
    // The value NUM_INTERRUPTS / INTERRUPT_JOB_DIVISOR must be at least 2.
    private final static int INTERRUPT_JOB_DIVISOR = 3;
    
    // The tenant id used in this test and that exists in the tenants table.
    private final static String TENANT_ID = "iplantc.org";
    
    /* ********************************************************************** */
    /*                            Set Up / Tear Down                          */
    /* ********************************************************************** */
    // NOTE: If you add more tests, you may need revisit before/after time.s 
    
    /* ---------------------------------------------------------------------- */
    /* setup:                                                                 */
    /* ---------------------------------------------------------------------- */
    @BeforeSuite
    private void setup()
    {
        // Set up thread-local context.
        TenancyHelper.setCurrentTenantId(TENANT_ID);
        
        // Clear the interrupts table for testing.
        JobInterruptDao.clearInterrupts();
    }
    
    /* ---------------------------------------------------------------------- */
    /* teardown:                                                              */
    /* ---------------------------------------------------------------------- */
    @AfterSuite
    private void teardown()
    {
        // Clear the interrupts table for testing.
        JobInterruptDao.clearInterrupts();
    }
    
    /* ********************************************************************** */
    /*                              Test Methods                              */
    /* ********************************************************************** */    
    /* ---------------------------------------------------------------------- */
    /* interruptTest:                                                         */
    /* ---------------------------------------------------------------------- */
    @Test(enabled=true)
    public void interruptTest() throws JobException
    {   
        // Create a bunch of interrupts.
        HashMap<Integer,JobInterrupt> interruptMap = generateInterruptMap();
        for (int i = 0; i < NUM_INTERRUPTS; i++)
        {
            JobInterrupt interrupt = interruptMap.get(i);
            int rows = JobInterruptDao.createInterrupt(interrupt);
            Assert.assertEquals(rows, 1, 
                "Unable to create interrupt: " + interrupt.toString());
        }
        
        // Retrieve all the interrupts.
        List<JobInterrupt> interruptList = JobInterruptDao.getInterrupts();
        Assert.assertEquals(interruptList.size(), NUM_INTERRUPTS,
                "Unexpected number of interrupts created.");
        
        // Retrieve interrupts for a specific job.  The ceil function is 
        // will always work for i mod 0. Save the ids of some interrupts
        // later processing.
        interruptList = JobInterruptDao.getInterrupts(getJobUuid(0), TENANT_ID);
        Assert.assertEquals( 
                (double) interruptList.size(),
                Math.ceil(((double)NUM_INTERRUPTS) / (double)INTERRUPT_JOB_DIVISOR), 
                "Unexpected number of interrupts created for " + getJobUuid(0) + ".");
        long deleteId = interruptList.get(0).getId();
        long expiredId = interruptList.get(1).getId();
        
        // Negative case: Try to retrieve for a bad tenant id.  Exception thrown here.
        interruptList = null;
        try {interruptList = JobInterruptDao.getInterrupts(getJobUuid(0), "badTenant");}
            catch (JobException e){}
        Assert.assertNull(interruptList,
                "Unexpected number of interrupts for non-existent tenant id.");
        
        // Negative case: Try to retrieve for a bad job id.
        interruptList = JobInterruptDao.getInterrupts("badJob", TENANT_ID);
        Assert.assertEquals(interruptList.size(), 0,
                "Unexpected number of interrupts for non-existent job id.");
        
        // Delete a specific interrupt.
        int deleted = JobInterruptDao.deleteInterrupt(deleteId, TENANT_ID);
        Assert.assertEquals(deleted, 1, "Unexpected number of interrupts deleted.");
        
        // Make sure the correct job's interrupt was deleted.
        interruptList = JobInterruptDao.getInterrupts(getJobUuid(0), TENANT_ID);
        Assert.assertEquals( 
                (double) interruptList.size(),
                Math.ceil(((double)NUM_INTERRUPTS) / (double)INTERRUPT_JOB_DIVISOR) - 1, 
                "Unexpected number of interrupts after deletion for " + getJobUuid(0) + ".");
        
        // Expire an interrupt.
        Date now = new Date();
        int expired = JobInterruptDao.updateExpiresAtDate(expiredId, TENANT_ID, now);
        Assert.assertEquals(expired, 1, "Unexpected number of interrupts expired.");
        try {Thread.sleep(1000);}   // Give interrupt time to expire
            catch (InterruptedException e) {} 
        
        // Delete all expired interrupts.
        deleted = JobInterruptDao.deleteExpiredInterrupts();
        Assert.assertEquals(deleted, 1, 
                "Unexpected number of interrupts deleted due to expiration.");
        
        // Make sure the correct job's interrupt was deleted.
        interruptList = JobInterruptDao.getInterrupts(getJobUuid(0), TENANT_ID);
        Assert.assertEquals( 
                (double) interruptList.size(),
                Math.ceil(((double)NUM_INTERRUPTS) / (double)INTERRUPT_JOB_DIVISOR) - 2, 
                "Unexpected number of interrupts after expiration deletion for " + getJobUuid(0) + ".");
        
        // Delete all interrupts.
        interruptList = JobInterruptDao.getInterrupts();
        Assert.assertEquals(interruptList.size(), NUM_INTERRUPTS - 2,
                "Unexpected number of existing interrupts.");
        for (JobInterrupt interrupt : interruptList)
        {
            deleted = JobInterruptDao.deleteInterrupt(interrupt.getId(), TENANT_ID);
            Assert.assertEquals(deleted, 1, "Unexpected number of interrupts deleted.");
        }
        
        // Make sure no interrupt still exist.
        interruptList = JobInterruptDao.getInterrupts();
        Assert.assertEquals(interruptList.size(), 0,
                "Unexpected number of interrupts still exist.");
    }

    /* ********************************************************************** */
    /*                            Private Methods                             */
    /* ********************************************************************** */
    /* ---------------------------------------------------------------------- */
    /* generateInterruptMap:                                                  */
    /* ---------------------------------------------------------------------- */
    private HashMap<Integer,JobInterrupt> generateInterruptMap()
    {
        // Result map.
        HashMap<Integer,JobInterrupt> map = new HashMap<Integer,JobInterrupt>();
        
        // Create the prescribed number of interrupts for each uniquely named 
        // job.  The keys are from 0 to NUM_INTERRUPTS - 1.
        for (int i = 0; i < NUM_INTERRUPTS; i++)
        {
            JobInterrupt interrupt = 
               new JobInterrupt(getJobUuid(i), TENANT_ID, getInterruptType(i));
            map.put(i, interrupt);
        }
        
        return map;
    }
    
    /* ---------------------------------------------------------------------- */
    /* getJobUuid:                                                            */
    /* ---------------------------------------------------------------------- */
    private String getJobUuid(int i)
    {
        return "TestJob-" + (i % (NUM_INTERRUPTS / INTERRUPT_JOB_DIVISOR));
    }
    
    /* ---------------------------------------------------------------------- */
    /* getInterruptType:                                                      */
    /* ---------------------------------------------------------------------- */
    private JobInterruptType getInterruptType(int i)
    {
        JobInterruptType[] types = JobInterruptType.values();
        return types[i % types.length];
    }
}
